# Deployments
A Deployment provides declarative updates for Pods and ReplicaSets.

You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate.You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments.

`Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.`

## Use Cases

The following are typical use cases for Deployments:

- Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not.
- Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment.
- Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment.
- Scale up the Deployment to facilitate more load.
- Pause the rollout of a Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout.
- Use the status of the Deployment as an indicator that a rollout has stuck.
- Clean up older ReplicaSets that you don't need anymore.

# Clone repository
```
git clone https://github.com/praveen1461996/kubernetes-learnings.git
```
```
cd kubernetes-learnings/k8s-objects/deployment
```

## Create Deployment 
Before you begin, make sure your Kubernetes cluster is up and running. Follow the steps given below to create the above Deployment:

- Create the Deployment by running the following command:
  `kubectl apply -f create-deployment.yml`
- Run `kubectl get deployments` to check if the Deployment was created.
- To see the Deployment rollout status, run `kubectl rollout status deployment/nginx-deployment`.
- Run the `kubectl get deployments` again a few seconds later
- To see the ReplicaSet (`rs`) created by the Deployment, run `kubectl get rs`.
- To see the labels automatically generated for each Pod, run `kubectl get pods --show-labels`
    The output is similar to:
```
NAME                                READY   STATUS    RESTARTS       AGE   LABELS
nginx-deployment-7fb96c846b-jhblk   1/1     Running   0              59m   app=nginx,pod-template-hash=7fb96c846b
nginx-deployment-7fb96c846b-qk22z   1/1     Running   0              59m   app=nginx,pod-template-hash=7fb96c846b
nginx-deployment-7fb96c846b-rzvwj   1/1     Running   0              59m   app=nginx,pod-template-hash=7fb96c846b
  ```
  
  `Note:
You must specify an appropriate selector and Pod template labels in a Deployment (in this case, app: nginx).

Do not overlap labels or selectors with other controllers (including other Deployments and StatefulSets). Kubernetes doesn't stop you from overlapping, and if multiple controllers have overlapping selectors those controllers might conflict and behave unexpectedly.`

## Pod-template-hash label

The pod-template-hash label is added by the Deployment controller to every ReplicaSet that a Deployment creates or adopts.

This label ensures that child ReplicaSets of a Deployment do not overlap. It is generated by hashing the PodTemplate of the ReplicaSet and using the resulting hash as the label value that is added to the ReplicaSet selector, Pod template labels, and in any existing Pods that the ReplicaSet might have.

## Update Deployment

```
Note: A Deployment's rollout is triggered if and only if the Deployment's Pod template (that is, .spec.template) is changed, for example if the labels or container images of the template are updated. Other updates, such as scaling the Deployment, do not trigger a rollout.
```
- Let's update the nginx Pods to use the nginx:1.16.1 image instead of the nginx:1.14.2 image.
 ``` 
 kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1
 ```
 or
 ``` 
 kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
 ```
Alternatively, you can edit the Deployment and change .spec.template.spec.containers[0].image from nginx:1.14.2 to nginx:1.16.1:
``` 
kubectl edit deployment/nginx-deployment 
```
- To see the rollout status, run:
  ` kubectl rollout status deployment/nginx-deployment `
  Get more details on your updated Deployment:
   `kubectl get deployments`
   `kubectl get rs`
   `kubectl get pods`
   `kubectl describe deployments`
 ## Rolling Back a Deployment 
 - Suppose that you made a typo while updating the Deployment, by putting the image name as nginx:1.161 instead of nginx:1.16.1:
 
   ```
   kubectl set image deployment/nginx-deployment nginx=nginx:1.161
   ```
 
 `
 Note: The Deployment controller stops the bad rollout automatically, and stops scaling up the new ReplicaSet. This depends on the rollingUpdate parameters (maxUnavailable specifically) that you have specified. Kubernetes by default sets the value to 25%.
 `
 - Looking at the Pods created, you see that 1 Pod created by new ReplicaSet is stuck in an image pull loop.

  `kubectl get pods`
  output is similiar like below
  ```
 NAME                                READY     STATUS             RESTARTS   AGE
nginx-deployment-1564180365-70iae   1/1       Running            0          25s
nginx-deployment-1564180365-jbqqo   1/1       Running            0          25s
nginx-deployment-1564180365-hysrc   1/1       Running            0          25s
nginx-deployment-3066724191-08mng   0/1       ImagePullBackOff   0          6s
  ```
## Rolling Back to a Previous Revision
- if you've decided to undo the current rollout and rollback to the previous revision:
 ```
 kubectl rollout undo deployment/nginx-deployment
 ```
- Alternatively, you can rollback to a specific revision by specifying it with --to-revision:
```
kubectl rollout undo deployment/nginx-deployment --to-revision=2
```
  

